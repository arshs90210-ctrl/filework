<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alkegen Scheduler v6.0 (Logic Enhanced)</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

  <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="loginScreen" class="login-wrapper">
    <div class="mb-8 text-center">
        <h1 class="text-2xl font-bold text-slate-800">Alkegen Scheduler</h1>
        <button onclick="handleLogin()" class="mt-4 bg-blue-600 text-white px-4 py-2 rounded">Enter System</button>
    </div>
</div>

<div id="mainApp" class="app-container hidden">
    <header>
        <div class="flex items-center gap-4">
            <h1 class="font-bold text-lg">Alkegen <span class="text-blue-600">Scheduler v6.0</span></h1>
            <div class="text-xs text-slate-500"><span id="userRoleBadge">Viewer</span></div>
        </div>
        <nav class="nav-group">
            <button onclick="switchView('gantt')" id="nav-gantt" class="nav-btn active">Schedule</button>
            <button onclick="switchView('sequencing')" id="nav-sequencing" class="nav-btn">Sequencing</button>
            <button onclick="switchView('staffing')" id="nav-staffing" class="nav-btn">Staffing</button>
            <button onclick="switchView('rates')" id="nav-rates" class="nav-btn">Rates</button>
            <button onclick="switchView('kpi')" id="nav-kpi" class="nav-btn">Analytics</button>
        </nav>
        <div class="flex items-center gap-3">
            <span id="userEmailDisplay" class="text-xs text-slate-400"></span>
            <button onclick="showModal('uploadModal')" class="admin-only bg-blue-600 text-white px-3 py-1 rounded text-xs">Import</button>
            <button onclick="handleLogout()" class="text-slate-400"><i class="fa-solid fa-right-from-bracket"></i></button>
        </div>
    </header>

    <div id="view-gantt" class="flex-1 flex flex-col relative fade-in overflow-hidden">
        <div class="h-14 border-b border-slate-200 bg-white flex items-center justify-between px-6 flex-shrink-0 z-40">
            <div class="flex items-center gap-6">
                <input type="date" id="simDate" class="font-bold text-slate-700" onchange="runEngine()">
                <span id="engineStatus" class="text-green-600 font-bold text-xs">READY</span>
            </div>
            <div class="flex items-center bg-slate-100 rounded p-1">
                <button onclick="changeZoom(-10)" class="w-6"><i class="fa-solid fa-minus"></i></button>
                <button onclick="changeZoom(10)" class="w-6"><i class="fa-solid fa-plus"></i></button>
            </div>
        </div>
        <div class="gantt-header-row">
            <div class="sidebar-header">
                <table class="data-table"><thead><tr>
                    <th style="width: 80px">Status</th><th style="width: 90px">Order</th><th style="width: 130px">Felt</th><th style="width: 100px">Fiber</th><th style="width: 100px">Status</th><th style="width: 50px">Qty</th>
                </tr></thead></table>
            </div>
            <div class="timeline-header-wrapper" id="timelineHeaderWrapper"><div id="timelineHeader" class="timeline-header"></div></div>
        </div>
        <div class="gantt-wrapper">
            <div class="gantt-scroll-container" id="mainScroll">
                <div class="gantt-sidebar"><table class="data-table"><tbody id="taskTableBody"></tbody></table></div>
                <div class="gantt-chart" id="ganttChart"><div id="timelineBody" class="pb-24"></div></div>
            </div>
        </div>
    </div>

    <div id="view-sequencing" class="hidden p-8"><h2 class="text-2xl font-bold">Sequencing</h2><div id="sequencingTableBody"></div></div>
    <div id="view-staffing" class="hidden p-8"><h2 class="text-2xl font-bold">Staffing</h2><div id="staffingTableBody"></div></div>
    <div id="view-rates" class="hidden p-8"><h2 class="text-2xl font-bold">Rates</h2><div id="ratesTableBody"></div></div>
    <div id="view-kpi" class="hidden p-8"><h2 class="text-2xl font-bold">Analytics</h2><div id="kpiYds"></div><div id="kpiRev"></div><div id="kpiLate"></div></div>
</div>

<div id="uploadModal" class="modal-bg">
    <div class="modal-content">
        <h2 class="font-bold mb-4">Import Data</h2>
        <input type="file" onchange="handleRateUpload(this)" class="mb-2 block"><small>Rates.xlsx</small>
        <input type="file" onchange="handleOrderUpload(this)" class="mb-2 block"><small>Orders.xlsx (Needs YARDSWIP col)</small>
        <input type="file" onchange="handleRouteUpload(this)" class="mb-2 block"><small>Digital Schedule.xlsx</small>
        <button onclick="runEngine()" class="mt-4 bg-blue-600 text-white px-4 py-2 rounded">Run</button>
        <button onclick="document.getElementById('uploadModal').style.display='none'" class="ml-2 px-4 py-2">Cancel</button>
        <div id="rateStatus"></div><div id="orderStatus"></div><div id="routeStatus"></div>
    </div>
</div>
<div id="tooltip" class="tooltip"></div>

<script id="worker-script" type="text/plain">
    self.onmessage = function(e) {
        const { orders, rates, config, downtime, simStart, routes, staffing, overrides } = e.data;
        const MACHINES = config.machines;
        
        let schedule = [];
        let now = simStart || new Date().getTime();
        let machineState = {};
        let activeDowntime = [...downtime];

        // 0. MATRIX CHANGEOVER LOGIC
        // "Light" fibers to "Dark" fibers is easier than "Dark" to "Light"
        const FIBER_MATRIX = {
            'POLYESTER': { 'ARAMID': 8, 'PPS': 4 },
            'ARAMID': { 'POLYESTER': 12, 'PPS': 6 },
            'PPS': { 'POLYESTER': 8, 'ARAMID': 8 },
            'GENERIC': { 'GENERIC': 2 }
        };

        function getChangeoverDuration(lastFiber, newFiber) {
            if (!lastFiber || !newFiber || lastFiber === newFiber) return 0;
            const lf = lastFiber.toUpperCase().split(' ')[0]; // Simplified matching
            const nf = newFiber.toUpperCase().split(' ')[0];
            
            if (FIBER_MATRIX[lf] && FIBER_MATRIX[lf][nf]) return FIBER_MATRIX[lf][nf] * 3600000;
            return 4 * 3600000; // Default penalty
        }

        // 1. STAFFING DOWNTIME GENERATION
        for(let d=0; d<60; d++) {
            const dayStart = now + (d * 86400000);
            const midnight = new Date(dayStart).setHours(0,0,0,0);
            Object.keys(staffing).forEach(machName => {
                const avail = staffing[machName];
                if(!avail) return;
                // Shift 1: 08:00-16:00, Shift 2: 16:00-00:00, Shift 3: 00:00-08:00
                if(!avail[0]) activeDowntime.push({ machine: machName, start: midnight + (8*3600000), end: midnight + (16*3600000), reason: 'Staffing' });
                if(!avail[1]) activeDowntime.push({ machine: machName, start: midnight + (16*3600000), end: midnight + (24*3600000), reason: 'Staffing' });
                if(!avail[2]) activeDowntime.push({ machine: machName, start: midnight, end: midnight + (8*3600000), reason: 'Staffing' });
            });
        }

        // Init State
        MACHINES.forEach(m => { machineState[m] = { time: now, lastFelt: null, lastFiber: null }; });

        // 2. SORTING (Campaign Mode)
        let queue = [...orders];
        if (config.campaign) {
            queue.sort((a,b) => {
                const fiberA = (a.fiber || '').toUpperCase();
                const fiberB = (b.fiber || '').toUpperCase();
                if(fiberA < fiberB) return -1;
                if(fiberA > fiberB) return 1;
                return (a.rtsDate || 0) - (b.rtsDate || 0);
            });
        } else {
            queue.sort((a,b) => (a.rtsDate || 0) - (b.rtsDate || 0));
        }

        // 3. MAIN SCHEDULING LOOP
        queue.forEach(ord => {
            const r = rates[ord.felt] || Object.values(rates)[0] || {card:250, finish:700, qc:400};
            let statusUpper = (ord.status || '').toUpperCase();
            
            // LOGIC IMPROVEMENT: Raw Material Constraint
            let materialReadyTime = now;
            if (statusUpper.includes('WAITING RAW') || statusUpper.includes('MATERIAL')) {
                materialReadyTime = now + (7 * 86400000); // Push out 7 days
            }

            // DYNAMIC ROUTING
            let routeSteps = routes[ord.felt];
            if (!routeSteps || routeSteps.length === 0) {
                 routeSteps = [
                    { step: 1, pool: MACHINES.filter(m => m.includes('Card')) },
                    { step: 2, pool: MACHINES.filter(m => m.includes('Bruckner') || m.includes('Kusters') || m.includes('Singer') || m.includes('Dilo')) },
                    { step: 3, pool: MACHINES.filter(m => m.includes('QC')) }
                 ];
            }

            // LOGIC IMPROVEMENT: WIP Handling (Netting Logic)
            let startStepIndex = 0;
            let currentReady = materialReadyTime;
            let wipQty = ord.wip || 0;
            let remainingQty = Math.max(0, ord.qty - wipQty); 
            let forcedFirstStep = null;

            if (remainingQty === 0 && ord.qty > 0) remainingQty = ord.qty; // Safety if WIP bad data

            // Detect if "In Process"
            if(statusUpper.includes('CARDING') && !statusUpper.includes('NOT')) {
                // It is currently ON a card. Find which one? 
                // Hard to parse from text, but we know it should start NOW and block machine.
                startStepIndex = 0; 
                forcedFirstStep = { startAt: now, duration: (remainingQty / r.card) }; // Calc remaining hours
            } 
            else if(statusUpper.includes('WAITING BRUCKNER')) {
                startStepIndex = 1;
            } 
            else if(statusUpper.includes('WAITING QC')) {
                startStepIndex = routeSteps.length - 1;
            }

            let allocations = [];

            for(let i = startStepIndex; i < routeSteps.length; i++) {
                const step = routeSteps[i];
                let pool = step.pool;
                let stepRate = 500; 
                const poolStr = pool.join(' ').toUpperCase();
                
                if(poolStr.includes('CARD')) stepRate = r.card || 250;
                else if(poolStr.includes('QC')) stepRate = r.qc || 400;
                else stepRate = r.finish || 700;

                // Duration Calculation (Netting)
                // If this is the first step and we have WIP, we might have less to do.
                // If it's a later step, we assume full Qty needs processing (unless specifically tracking per-station WIP).
                // For simplicity: If "Carding" status, card step gets remainingQty. Subsequent steps get full Qty (as they haven't started).
                let stepQty = (i === startStepIndex && forcedFirstStep) ? remainingQty : ord.qty;
                let stepDurHrs = stepQty / stepRate;

                // Move times (Buffers)
                if(i > startStepIndex) {
                    if(poolStr.includes('QC')) currentReady += 1800000; // 30m Cool down
                    else currentReady += 3600000; // 1hr Move time
                }

                // ALLOCATE
                // Logic Improvement: Pass 'forcedFirstStep' to allocate logic
                let forceParams = (i === startStepIndex) ? forcedFirstStep : null;
                
                const res = allocate(pool, currentReady, stepDurHrs, ord.felt, ord.fiber, forceParams);
                
                allocations.push({ stepName: step.step, ...res });
                currentReady = res.end;
            }

            // Save to schedule
            const finalEnd = allocations.length > 0 ? allocations[allocations.length-1].end : now;
            schedule.push({
                ...ord,
                allocations: allocations,
                globalEnd: finalEnd,
                isLate: finalEnd > ord.rtsDate
            });
        });

        // ALLOCATION FUNCTION (With Matrix & Force Logic)
        function allocate(pool, readyTime, durHrs, felt, fiber, forceParams) {
            if(!pool || pool.length === 0) return { mach:'Err', start:readyTime, end:readyTime };
            const durMs = durHrs * 3600000;
            const PATIENCE_THRESHOLD = 24 * 3600000; 

            // FORCE LOGIC (WIP Handling)
            // If this job is already running (forceParams), we pick the first machine in pool (or ideal logic: parse machine name)
            // and schedule it starting at 'now' regardless of conflict, assuming the conflict IS this job.
            if (forceParams) {
                const mName = pool[0]; 
                const start = forceParams.startAt;
                const end = start + durMs; // Use calculated remaining duration
                
                // Update state
                if(!machineState[mName]) machineState[mName] = { time: now, lastFelt: null, lastFiber: null };
                machineState[mName].time = end;
                machineState[mName].lastFelt = felt;
                machineState[mName].lastFiber = fiber;
                
                return { mach: mName, start: start, end: end };
            }

            // NORMAL LOGIC
            let options = pool.map(mName => {
                const mState = machineState[mName] || { time: now, lastFelt: null, lastFiber: null };
                
                let start = Math.max(mState.time, readyTime, now);
                
                // LOGIC IMPROVEMENT: Matrix Changeover
                if(mState.lastFelt) {
                    // If Same Felt, 0. If Different Felt but Same Fiber, small penalty. Different Fiber, Matrix penalty.
                    if (mState.lastFelt === felt) {
                        start += 0;
                    } else {
                        const penalty = getChangeoverDuration(mState.lastFiber, fiber);
                        start += penalty;
                    }
                }

                // Downtime check
                let conflict = true;
                let attempts = 0;
                while(conflict && attempts < 50) {
                    conflict = false;
                    const potentialEnd = start + durMs;
                    const dt = activeDowntime.find(d => d.machine === mName && d.start < potentialEnd && d.end > start);
                    if (dt) {
                        start = dt.end;
                        conflict = true;
                    }
                    attempts++;
                }

                return { mach: mName, start: start, end: start + durMs };
            });

            // Selection
            const bestPossibleTime = Math.min(...options.map(o => o.end));
            let selectedOption = null;

            // Preference vs Speed Heuristic
            for (let i = 0; i < options.length; i++) {
                const opt = options[i];
                if (opt.end <= (bestPossibleTime + PATIENCE_THRESHOLD)) {
                    selectedOption = opt;
                    break;
                }
            }
            if (!selectedOption) selectedOption = options.reduce((prev, curr) => prev.end < curr.end ? prev : curr);

            // Update State
            const mName = selectedOption.mach;
            if(!machineState[mName]) machineState[mName] = { time: now, lastFelt: null, lastFiber: null };
            machineState[mName].time = selectedOption.end;
            machineState[mName].lastFelt = felt;
            machineState[mName].lastFiber = fiber;

            return selectedOption;
        }

        // ANALYTICS
        let dayLoads = {};
        schedule.forEach(s => {
            s.allocations.forEach(t => {
                if(t.start && t.end) {
                    const startDay = Math.floor(t.start / 86400000);
                    const endDay = Math.floor(t.end / 86400000);
                    for(let i=startDay; i<=endDay; i++) dayLoads[i] = (dayLoads[i]||0) + 1;
                }
            });
        });

        self.postMessage({ schedule, dayLoads });
    };
</script>

<script src="app.js"></script>
</body>
</html>
